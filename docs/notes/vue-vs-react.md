---
title: WIP:聊一聊面试中 Vue 和 React 的区别
lang: zh
description: 在国内这是一道很经典的面试题，这道题的特殊就在于它并没有一个标准的答案。但是它却是一道考研前端开发人员水平的标尺之一。
date: 2024-06-08 10:40:00
---

[[toc]]

> 本篇阅读请建立在有一定 Vue 和 React 基础之上。

## 设计方向

**Vue** 和 **React** 都是 **JavaScript Framework**。**React** 是一个用于构建用户界面的 JavaScript 库，而**Vue** 主要围绕着 **渐进式**，"渐进"意味着其功能和范围可以随着项目的增长而轻松扩展。

这也正是会让人觉得 **Vue** 的上手难度比 **React** 要简单很多。

## 版本差异

**React** 至始至终都在同一个链路上继续迭代维护。但是 **Vue** 由于之前设计上的缺陷，在新特性的普及下进行了重构新起了项目  **Vue3.0**。

为了保证之前版本的兼容可以用性。当下存在 **Vue2.0** 与 **Vue3.0** 并行维护的状态。

**在下面的讨论中我们将同时比对 Vue2、Vue3 和 React**。

## 文件差异

### .jsx 文件

在 **React** 工程中，每一个 **页面/组件** 都是编码在 `.jsx` 文件中。`.jsx`文件是一种用于 **React** 应用程序的 **JavaScript** 语法扩展。它允许 **React** 开发人员在 **JavaScript** 中使用类似 **HTML** 的标记来描述 **React** 组件的外观和行为，使得 **React** 组件的编写更为简洁和直观。

### .vue 文件

在 **Vue** 中，`.vue`文件是 `Vue.js` 框架中特有的文件格式。
它是一个 **单文件组件（Single-File Component）**，将模板、脚本（JavaScript 代码）、样式（CSS 样式）等相关内容通过对应标签规范整合在一个文件中。

在 **Vue** 工程中，`.jsx` 文件格式也是被框架所支持的。但是官方建议还是使用 `.vue` 的模板形式。

这是因为在编译时，**Vue** 的工程会进行例如 **静态提升** 等优化手段以提高框架的性能。如果使用 `.jsx` 模式将会失去这个特性。

### 内容差异

**React** 的组件模式存在 **类组件** 和 **函数式组件**。**Vue2** 的组件模式是 **Options API**，**Vue3** 的组件模式是 **Composition API。**
在内容上 **React** 和 **Vue** 的内容方式是完全不同的。但是在设计思路上，**Vue3** 和 **React** 却有相似之处。

#### React 

**首先，我们先聊聊 React，它的设计思路多方面体现了函数式编程的理念。**

**函数组件**

**函数式组件**是当下 **React** 中最流行的编程方式。相比类组件，更简洁、直观，没有复杂的类定义和生命周期方法的样板代码。代码结构相对简单，对于开发者来说更容易理解和维护。

**React** 中的组件应该尽量是**纯函数**，即对于相同的输入，总是返回相同的输出，并且没有副作用。这样可以提高组件的可预测性和可靠性。

更符合现代编程中对函数式风格的偏好。


**数据的不可变**

**React** 鼓励使用不可变的数据结构，这与函数式编程中强调的不可变数据的理念相符合。通过使用不可变数据，可以更方便地进行数据的比较和渲染优化。

**数据流**

**React** 通过单向的数据流来管理组件之间的通信，这与函数式编程中的数据流理念相似。数据从父组件流向子组件，通过属性传递，子组件通过回调函数将数据返回给父组件。

**函数式钩子**

**React Hooks** 是 **React** 中的一种新特性，它允许在函数组件中使用状态和其他功能。**Hooks** 提供了一种函数式的方式来管理组件的状态和副作用，使得函数组件更具表现力和可复用性。

#### Vue

**现在，我们在聊聊 Vue，Vue2 和 Vue3 的变更是不兼容的重构。组件模式上也是不同的理念。**

**Vue2.0**

**Vue2** 的组件设计上提倡的是 **Options API**。它是一种将组件的不同方面（如数据、方法、计算属性等）通过对象属性的方式进行配置和组织的方式。

它更倾向于一种基于对象和属性配置的编程风格，通过明确划分不同的选项来构建组件的行为和状态。以一种直观、面向对象的方式来构建和管理 **Vue** 组件。

**Vue3.0**

**Vue3** 的 **Composition API** 体现了一些函数式编程的思想这与 **React** 的理念存在相同之处，但不能简单地说它完全就是函数式编程。
**Composition API** 强调将相关功能组合到一起，通过函数来组织和管理组件的逻辑，这与函数式编程中注重函数的组合和数据的不可变性等理念有一定的契合之处。

**Composition API** 借鉴了一些函数式编程的优点来改进组件的开发方式和逻辑组织，**Vue3** 整体是一个多范式融合的框架。

## 生命周期钩子

**React** 和 **Vue** 都具有完善的生命周期钩子。**React** 体现在 类组件中，在 **Vue** 中 **Vue2** 和 **Vue3** 两个版本的组件中都有体现。

部分人会认为 **React** 的函数式组件也存在生命周期钩子，它可以用 **useEffect** 来实现。但是 **useEffect** 的理念并不是生命周期钩子，它的含义表示着**副作用**。只是它产生副作用的效果可以替作生命周期钩子来使用。很多人认为它就是生命周期钩子，这其实是一个误区。

#### render 

在 **Vue** 和 **React** 中，**render** 方法的主要目的都是将组件的状态或数据转换为用户界面。它负责描述组件应该如何呈现。两者都使用 **虚拟DOM** 来提高性能。**render** 方法会创建**虚拟DOM树**，然后与实际的 **DOM** 进行比较，只更新必要的部分，以减少对 **DOM** 的操作。

但是 **render** 方法也存在差异，虽然它们的作用相同的，但是它们的实现方式是不同的。**React** 是在组件 **Js** 代码中，通过原生 **Js** 实现模板中的常见语法，更加纯粹和原生。而 **Vue** 是在和组件 **Js** 代码分离的单独模板中，通过指令来实现的。

在渲染过程中，**Vue** 可以更快地计算出 **虚拟Dom** 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

但是在 **React** 中，应用的状态被改变时，全部子组件都会重新渲染。通过 **shouldComponentUpdate** 这个生命周期方法可以进行控制，但 **Vue** 将此视为默认的优化。

## 指令

**Vue** 的"渐进"意味着其功能和范围可以随着项目的增长而轻松扩展。**Vue** 中的指令是一种特殊的属性，用于在模板中添加动态行为。指令以 `v-` 开头，后面跟着指令的名称。这个在 **React** 中是不存在的。

通过这些指令，帮助我们更方便地操作 **Dom**，实现动态效果和交互功能。在 **React** 中只能通过编码的方式自行实现。

## 虚拟Dom

**React** 和 **Vue** 的 **虚拟Dom** 的理念是一样的。都是用 Js对象的方式来模拟 **真实Dom**，用 **虚拟Dom** 来进行 **diff** 达到最小化更新 **真实Dom**。它们只是数据结构上会有所差异。

## diff 

**React** 和 **Vue** 在 **diff** 上它们的相同之处是都采用了只比较同层级的节点、通过 **key** 属性来识别节点等优化方案。

不同的是，**Vue** 的 **diff** 是细粒度的比较。

并且在 **Vue2** 中，**diff算法** 采用 **双端比较** 的方式，同时从新旧数组的两端开始比较，找到相同的节点后进行移动和更新。

**Vue3** 的 **diff算法** 采用 **最长递增子序列** 的方式，通过找到新旧数组中最长的递增子序列，来减少不必要的节点移动和更新。

**React** 的 **diff算法** 采用仅右移的方式，从左到右依次比较新旧子节点，如果节点相同则直接移动，不同则删除重建。

## 响应式数据

**React** 和 **Vue** 在响应式数据设计上采用的理念也完全不同。

**Vue** 的设计方案是 数据劫持。主要通过 **Object.defineProperty()** 和 **Proxy** 来实现对属性的劫持，并配置发布订阅和依赖手机的模式，监听数据的变化从而触发视图更新。当数据发生变化时，能精确地知道是哪个属性变化，然后进行相应处理。

然而 **React** 自身并没有像 **Vue** 那样直接对数据进行深度监听。通常是通过调用 **setState()** 方法来通知组件状态改变，进而引发重新渲染。它是一种基于状态变化来驱动视图更新的机制。

## 数据更新的时机

在 **Vue** 中，更改响应式数据是同步的。这意味着当你修改 **Vue** 组件中的响应式数据时，视图会立即更新以反映这些更改。

而在 **React** 中，**setState** 方法是异步的，这是因为 **React** 为了提高性能和优化渲染过程，采用了一种称为“批量更新”的机制。当你调用 **setState** 时，**React** 不会立即更新组件的状态并重新渲染视图，而是将多个 **setState** 调用合并成一个批次，并在稍后的时间点一次性地更新组件的状态和视图。

## Html

**React** 中 **Html内容** 是必须有一个根标签进行包裹。如果你不想设置任何 **Html标签** 可以直接使用 `<></>` 空标签包裹。

再 **Vue** 中 **Html内容** 必须放在 **template标签** 中，**template标签** 这种也需要一个根标签进行包裹。**Vue** 并没有提供 `<></>` 空标签来解决这个。但是在 **Vue3** 中 已经支持 **template标签** 中可以不用根标签进行包裹。这是因为在编译解析时，会自动添加 **Document Fragment** 来保证根标签的存在。

## Css

在 **React** 中，**css** 编写在独立的 **样式文件（.css、.less、.scss）** 中。也可以采用 **css-in-js** 的方式。

但是在 **Vue** 中，**css** 大多数是编写在 `.vue` 文件中的 **style标签** 中。当然也可以编写在独立的 **样式文件（.css、.less、.scss）** 中，但是需要通过 `@import` 的方式导入 **style标签** 中。

**React** 和 **Vue** 都会面的一个问题，那就是当 **css** 的样式名称相同时会造成全局污染。这个问题在协同开发的时候经常会遇到。最直观的解决方案就是样式隔离。

在 **Vue** 中可以直接在 **style标签** 中开启内置 **scoped属性**，这个属性会以组件为单位开启 **css沙箱机制** 进行样式隔离。

在 **React** 中采用 **css modules** 的方案进行样式隔离。当然 **Vue** 也可以使用 **css modules** 的方案解决，需要配置构建工具使用。

## Ts

当前绝大部分的项目都是采用 **TypeScript** 的方式。因为 **TypeScript** 的特性，在协议研发中起到了重要作用。那么在 **React** 可以采用 `.tsx` 文件的方式开启 **TypeScript** 模式。在 **Vue** 中，可以在 **script标签** 中设置 **lang属性** 为 **ts** 来开启 **TypeScript** 模式。


## 事件Event

**React** 和 **Vue** 的事件系统是截然不同的。React 中会 **劫持事件**，主要原因是为了实现更好的性能优化和跨浏览器兼容性。通过劫持事件，**React** 可以在其内部的事件系统中统一处理事件，确保在不同浏览器和环境下的一致性。这有助于避免浏览器之间的差异，并提供更可靠的事件处理行为。

但是在 **Vue** 中，事件处理是通过在组件的模板中添加事件监听器来实现的，例如 **@click、@submit** 等。当事件触发时，**Vue** 会调用相应的事件处理函数来执行相应的操作。
